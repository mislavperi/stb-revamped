// Code generated by ogen, DO NOT EDIT.

package server

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes CreateStbUserBadRequest as json.
func (s *CreateStbUserBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateStbUserBadRequest from json.
func (s *CreateStbUserBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateStbUserBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateStbUserBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateStbUserBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateStbUserBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateStbUserInternalServerError as json.
func (s *CreateStbUserInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateStbUserInternalServerError from json.
func (s *CreateStbUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateStbUserInternalServerError to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateStbUserInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateStbUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateStbUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateStbUserUnauthorized as json.
func (s *CreateStbUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateStbUserUnauthorized from json.
func (s *CreateStbUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateStbUserUnauthorized to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateStbUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateStbUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateStbUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTimeEntryBadRequest as json.
func (s *CreateTimeEntryBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateTimeEntryBadRequest from json.
func (s *CreateTimeEntryBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTimeEntryBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateTimeEntryBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTimeEntryBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTimeEntryBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTimeEntryInternalServerError as json.
func (s *CreateTimeEntryInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateTimeEntryInternalServerError from json.
func (s *CreateTimeEntryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTimeEntryInternalServerError to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateTimeEntryInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTimeEntryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTimeEntryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTimeEntryRequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTimeEntryRequestBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("matterId")
		e.Int16(s.MatterId)
	}
	{
		e.FieldStart("trackingEntityId")
		e.Int32(s.TrackingEntityId)
	}
	{
		e.FieldStart("isGratias")
		e.Bool(s.IsGratias)
	}
	{
		e.FieldStart("timeSpent")
		e.Float64(s.TimeSpent)
	}
	{
		e.FieldStart("hasStatus")
		e.Int16(s.HasStatus)
	}
	{
		if s.InvoiceComment.Set {
			e.FieldStart("invoiceComment")
			s.InvoiceComment.Encode(e)
		}
	}
	{
		if s.InternalNote.Set {
			e.FieldStart("internalNote")
			s.InternalNote.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateTimeEntryRequestBody = [7]string{
	0: "matterId",
	1: "trackingEntityId",
	2: "isGratias",
	3: "timeSpent",
	4: "hasStatus",
	5: "invoiceComment",
	6: "internalNote",
}

// Decode decodes CreateTimeEntryRequestBody from json.
func (s *CreateTimeEntryRequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTimeEntryRequestBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matterId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int16()
				s.MatterId = int16(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matterId\"")
			}
		case "trackingEntityId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.TrackingEntityId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trackingEntityId\"")
			}
		case "isGratias":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsGratias = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isGratias\"")
			}
		case "timeSpent":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.TimeSpent = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeSpent\"")
			}
		case "hasStatus":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int16()
				s.HasStatus = int16(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasStatus\"")
			}
		case "invoiceComment":
			if err := func() error {
				s.InvoiceComment.Reset()
				if err := s.InvoiceComment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoiceComment\"")
			}
		case "internalNote":
			if err := func() error {
				s.InternalNote.Reset()
				if err := s.InternalNote.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internalNote\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTimeEntryRequestBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateTimeEntryRequestBody) {
					name = jsonFieldsNameOfCreateTimeEntryRequestBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTimeEntryRequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTimeEntryRequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateTimeEntryUnauthorized as json.
func (s *CreateTimeEntryUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateTimeEntryUnauthorized from json.
func (s *CreateTimeEntryUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTimeEntryUnauthorized to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateTimeEntryUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTimeEntryUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTimeEntryUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteStbUserByUUIDBadRequest as json.
func (s *DeleteStbUserByUUIDBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteStbUserByUUIDBadRequest from json.
func (s *DeleteStbUserByUUIDBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteStbUserByUUIDBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteStbUserByUUIDBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteStbUserByUUIDBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteStbUserByUUIDBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteStbUserByUUIDInternalServerError as json.
func (s *DeleteStbUserByUUIDInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteStbUserByUUIDInternalServerError from json.
func (s *DeleteStbUserByUUIDInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteStbUserByUUIDInternalServerError to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteStbUserByUUIDInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteStbUserByUUIDInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteStbUserByUUIDInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteStbUserByUUIDNotFound as json.
func (s *DeleteStbUserByUUIDNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteStbUserByUUIDNotFound from json.
func (s *DeleteStbUserByUUIDNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteStbUserByUUIDNotFound to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteStbUserByUUIDNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteStbUserByUUIDNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteStbUserByUUIDNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteStbUserByUUIDUnauthorized as json.
func (s *DeleteStbUserByUUIDUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteStbUserByUUIDUnauthorized from json.
func (s *DeleteStbUserByUUIDUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteStbUserByUUIDUnauthorized to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteStbUserByUUIDUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteStbUserByUUIDUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteStbUserByUUIDUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfErrorMessage = [1]string{
	0: "message",
}

// Decode decodes ErrorMessage from json.
func (s *ErrorMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrorMessage) {
					name = jsonFieldsNameOfErrorMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetStbUserByUUIDBadRequest as json.
func (s *GetStbUserByUUIDBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetStbUserByUUIDBadRequest from json.
func (s *GetStbUserByUUIDBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStbUserByUUIDBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetStbUserByUUIDBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStbUserByUUIDBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStbUserByUUIDBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetStbUserByUUIDInternalServerError as json.
func (s *GetStbUserByUUIDInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetStbUserByUUIDInternalServerError from json.
func (s *GetStbUserByUUIDInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStbUserByUUIDInternalServerError to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetStbUserByUUIDInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStbUserByUUIDInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStbUserByUUIDInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetStbUserByUUIDNotFound as json.
func (s *GetStbUserByUUIDNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetStbUserByUUIDNotFound from json.
func (s *GetStbUserByUUIDNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStbUserByUUIDNotFound to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetStbUserByUUIDNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStbUserByUUIDNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStbUserByUUIDNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetStbUserByUUIDUnauthorized as json.
func (s *GetStbUserByUUIDUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetStbUserByUUIDUnauthorized from json.
func (s *GetStbUserByUUIDUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStbUserByUUIDUnauthorized to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetStbUserByUUIDUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStbUserByUUIDUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStbUserByUUIDUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetStbUsersInternalServerError as json.
func (s *GetStbUsersInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetStbUsersInternalServerError from json.
func (s *GetStbUsersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStbUsersInternalServerError to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetStbUsersInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStbUsersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStbUsersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetStbUsersOKApplicationJSON as json.
func (s GetStbUsersOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []StbUser(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetStbUsersOKApplicationJSON from json.
func (s *GetStbUsersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStbUsersOKApplicationJSON to nil")
	}
	var unwrapped []StbUser
	if err := func() error {
		unwrapped = make([]StbUser, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem StbUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetStbUsersOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetStbUsersOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStbUsersOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetStbUsersUnauthorized as json.
func (s *GetStbUsersUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetStbUsersUnauthorized from json.
func (s *GetStbUsersUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStbUsersUnauthorized to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetStbUsersUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStbUsersUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStbUsersUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTimeEntriesInternalServerError as json.
func (s *GetTimeEntriesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTimeEntriesInternalServerError from json.
func (s *GetTimeEntriesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTimeEntriesInternalServerError to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTimeEntriesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTimeEntriesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTimeEntriesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTimeEntriesOKApplicationJSON as json.
func (s GetTimeEntriesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []TimeEntry(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetTimeEntriesOKApplicationJSON from json.
func (s *GetTimeEntriesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTimeEntriesOKApplicationJSON to nil")
	}
	var unwrapped []TimeEntry
	if err := func() error {
		unwrapped = make([]TimeEntry, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TimeEntry
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTimeEntriesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetTimeEntriesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTimeEntriesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTimeEntriesUnauthorized as json.
func (s *GetTimeEntriesUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetTimeEntriesUnauthorized from json.
func (s *GetTimeEntriesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTimeEntriesUnauthorized to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTimeEntriesUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTimeEntriesUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTimeEntriesUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveTimeEntryInternalServerError as json.
func (s *RemoveTimeEntryInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveTimeEntryInternalServerError from json.
func (s *RemoveTimeEntryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveTimeEntryInternalServerError to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveTimeEntryInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveTimeEntryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveTimeEntryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveTimeEntryUnauthorized as json.
func (s *RemoveTimeEntryUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes RemoveTimeEntryUnauthorized from json.
func (s *RemoveTimeEntryUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveTimeEntryUnauthorized to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveTimeEntryUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveTimeEntryUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveTimeEntryUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServerErrorResponse as json.
func (s ServerErrorResponse) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes ServerErrorResponse from json.
func (s *ServerErrorResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerErrorResponse to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ServerErrorResponse(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ServerErrorResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerErrorResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StbUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StbUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("stbUserId")
		e.Int32(s.StbUserId)
	}
	{
		e.FieldStart("stbUserUuid")
		json.EncodeUUID(e, s.StbUserUuid)
	}
	{
		e.FieldStart("stbCustomerId")
		e.Int32(s.StbCustomerId)
	}
	{
		e.FieldStart("hasStatus")
		e.Int32(s.HasStatus)
	}
	{
		e.FieldStart("hasAuthMethod")
		e.Int32(s.HasAuthMethod)
	}
	{
		e.FieldStart("firstName")
		e.Str(s.FirstName)
	}
	{
		e.FieldStart("middleName")
		e.Str(s.MiddleName)
	}
	{
		e.FieldStart("lastName")
		e.Str(s.LastName)
	}
	{
		e.FieldStart("initials")
		e.Str(s.Initials)
	}
	{
		e.FieldStart("dtCreated")
		json.EncodeDateTime(e, s.DtCreated)
	}
	{
		e.FieldStart("dtModified")
		json.EncodeDateTime(e, s.DtModified)
	}
}

var jsonFieldsNameOfStbUser = [11]string{
	0:  "stbUserId",
	1:  "stbUserUuid",
	2:  "stbCustomerId",
	3:  "hasStatus",
	4:  "hasAuthMethod",
	5:  "firstName",
	6:  "middleName",
	7:  "lastName",
	8:  "initials",
	9:  "dtCreated",
	10: "dtModified",
}

// Decode decodes StbUser from json.
func (s *StbUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StbUser to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "stbUserId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.StbUserId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stbUserId\"")
			}
		case "stbUserUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.StbUserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stbUserUuid\"")
			}
		case "stbCustomerId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.StbCustomerId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stbCustomerId\"")
			}
		case "hasStatus":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.HasStatus = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasStatus\"")
			}
		case "hasAuthMethod":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.HasAuthMethod = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasAuthMethod\"")
			}
		case "firstName":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.FirstName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstName\"")
			}
		case "middleName":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.MiddleName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"middleName\"")
			}
		case "lastName":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.LastName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastName\"")
			}
		case "initials":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Initials = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initials\"")
			}
		case "dtCreated":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.DtCreated = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dtCreated\"")
			}
		case "dtModified":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.DtModified = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dtModified\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StbUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStbUser) {
					name = jsonFieldsNameOfStbUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StbUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StbUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StbUserCreateRequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StbUserCreateRequestBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("stbUserUuid")
		json.EncodeUUID(e, s.StbUserUuid)
	}
	{
		e.FieldStart("stbCustomerId")
		e.Int32(s.StbCustomerId)
	}
	{
		e.FieldStart("hasStatus")
		e.Int32(s.HasStatus)
	}
	{
		e.FieldStart("hasAuthMethod")
		e.Int32(s.HasAuthMethod)
	}
	{
		e.FieldStart("firstName")
		e.Str(s.FirstName)
	}
	{
		e.FieldStart("middleName")
		e.Str(s.MiddleName)
	}
	{
		e.FieldStart("lastName")
		e.Str(s.LastName)
	}
	{
		e.FieldStart("initials")
		e.Str(s.Initials)
	}
}

var jsonFieldsNameOfStbUserCreateRequestBody = [8]string{
	0: "stbUserUuid",
	1: "stbCustomerId",
	2: "hasStatus",
	3: "hasAuthMethod",
	4: "firstName",
	5: "middleName",
	6: "lastName",
	7: "initials",
}

// Decode decodes StbUserCreateRequestBody from json.
func (s *StbUserCreateRequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StbUserCreateRequestBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "stbUserUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.StbUserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stbUserUuid\"")
			}
		case "stbCustomerId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.StbCustomerId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stbCustomerId\"")
			}
		case "hasStatus":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.HasStatus = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasStatus\"")
			}
		case "hasAuthMethod":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.HasAuthMethod = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasAuthMethod\"")
			}
		case "firstName":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.FirstName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstName\"")
			}
		case "middleName":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.MiddleName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"middleName\"")
			}
		case "lastName":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.LastName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastName\"")
			}
		case "initials":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Initials = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initials\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StbUserCreateRequestBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStbUserCreateRequestBody) {
					name = jsonFieldsNameOfStbUserCreateRequestBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StbUserCreateRequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StbUserCreateRequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StbUserUpdateRequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StbUserUpdateRequestBody) encodeFields(e *jx.Encoder) {
	{
		if s.StbCustomerId.Set {
			e.FieldStart("stbCustomerId")
			s.StbCustomerId.Encode(e)
		}
	}
	{
		if s.HasStatus.Set {
			e.FieldStart("hasStatus")
			s.HasStatus.Encode(e)
		}
	}
	{
		if s.HasAuthMethod.Set {
			e.FieldStart("hasAuthMethod")
			s.HasAuthMethod.Encode(e)
		}
	}
	{
		if s.FirstName.Set {
			e.FieldStart("firstName")
			s.FirstName.Encode(e)
		}
	}
	{
		if s.MiddleName.Set {
			e.FieldStart("middleName")
			s.MiddleName.Encode(e)
		}
	}
	{
		if s.LastName.Set {
			e.FieldStart("lastName")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Initials.Set {
			e.FieldStart("initials")
			s.Initials.Encode(e)
		}
	}
}

var jsonFieldsNameOfStbUserUpdateRequestBody = [7]string{
	0: "stbCustomerId",
	1: "hasStatus",
	2: "hasAuthMethod",
	3: "firstName",
	4: "middleName",
	5: "lastName",
	6: "initials",
}

// Decode decodes StbUserUpdateRequestBody from json.
func (s *StbUserUpdateRequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StbUserUpdateRequestBody to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "stbCustomerId":
			if err := func() error {
				s.StbCustomerId.Reset()
				if err := s.StbCustomerId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stbCustomerId\"")
			}
		case "hasStatus":
			if err := func() error {
				s.HasStatus.Reset()
				if err := s.HasStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasStatus\"")
			}
		case "hasAuthMethod":
			if err := func() error {
				s.HasAuthMethod.Reset()
				if err := s.HasAuthMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasAuthMethod\"")
			}
		case "firstName":
			if err := func() error {
				s.FirstName.Reset()
				if err := s.FirstName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstName\"")
			}
		case "middleName":
			if err := func() error {
				s.MiddleName.Reset()
				if err := s.MiddleName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"middleName\"")
			}
		case "lastName":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastName\"")
			}
		case "initials":
			if err := func() error {
				s.Initials.Reset()
				if err := s.Initials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initials\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StbUserUpdateRequestBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StbUserUpdateRequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StbUserUpdateRequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TimeEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TimeEntry) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("timeEntryUuid")
		json.EncodeUUID(e, s.TimeEntryUuid)
	}
	{
		e.FieldStart("dtLogged")
		json.EncodeDateTime(e, s.DtLogged)
	}
	{
		e.FieldStart("workedByName")
		e.Str(s.WorkedByName)
	}
	{
		e.FieldStart("clientName")
		e.Str(s.ClientName)
	}
	{
		e.FieldStart("matterName")
		e.Str(s.MatterName)
	}
	{
		e.FieldStart("hoursLogged")
		e.Float64(s.HoursLogged)
	}
	{
		e.FieldStart("dtStart")
		json.EncodeDateTime(e, s.DtStart)
	}
	{
		e.FieldStart("dtStop")
		json.EncodeDateTime(e, s.DtStop)
	}
	{
		e.FieldStart("rate")
		e.Float32(s.Rate)
	}
	{
		e.FieldStart("amount")
		e.Float32(s.Amount)
	}
	{
		e.FieldStart("isBillable")
		e.Bool(s.IsBillable)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
}

var jsonFieldsNameOfTimeEntry = [13]string{
	0:  "timeEntryUuid",
	1:  "dtLogged",
	2:  "workedByName",
	3:  "clientName",
	4:  "matterName",
	5:  "hoursLogged",
	6:  "dtStart",
	7:  "dtStop",
	8:  "rate",
	9:  "amount",
	10: "isBillable",
	11: "description",
	12: "notes",
}

// Decode decodes TimeEntry from json.
func (s *TimeEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TimeEntry to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timeEntryUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TimeEntryUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeEntryUuid\"")
			}
		case "dtLogged":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.DtLogged = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dtLogged\"")
			}
		case "workedByName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.WorkedByName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workedByName\"")
			}
		case "clientName":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ClientName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientName\"")
			}
		case "matterName":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.MatterName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matterName\"")
			}
		case "hoursLogged":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.HoursLogged = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hoursLogged\"")
			}
		case "dtStart":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.DtStart = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dtStart\"")
			}
		case "dtStop":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.DtStop = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dtStop\"")
			}
		case "rate":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Float32()
				s.Rate = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate\"")
			}
		case "amount":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Amount = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "isBillable":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsBillable = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isBillable\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TimeEntry")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTimeEntry) {
					name = jsonFieldsNameOfTimeEntry[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TimeEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TimeEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateStbUserByUUIDBadRequest as json.
func (s *UpdateStbUserByUUIDBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateStbUserByUUIDBadRequest from json.
func (s *UpdateStbUserByUUIDBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateStbUserByUUIDBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateStbUserByUUIDBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateStbUserByUUIDBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateStbUserByUUIDBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateStbUserByUUIDInternalServerError as json.
func (s *UpdateStbUserByUUIDInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateStbUserByUUIDInternalServerError from json.
func (s *UpdateStbUserByUUIDInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateStbUserByUUIDInternalServerError to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateStbUserByUUIDInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateStbUserByUUIDInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateStbUserByUUIDInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateStbUserByUUIDNotFound as json.
func (s *UpdateStbUserByUUIDNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateStbUserByUUIDNotFound from json.
func (s *UpdateStbUserByUUIDNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateStbUserByUUIDNotFound to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateStbUserByUUIDNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateStbUserByUUIDNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateStbUserByUUIDNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateStbUserByUUIDUnauthorized as json.
func (s *UpdateStbUserByUUIDUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateStbUserByUUIDUnauthorized from json.
func (s *UpdateStbUserByUUIDUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateStbUserByUUIDUnauthorized to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateStbUserByUUIDUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateStbUserByUUIDUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateStbUserByUUIDUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTimeEntryBadRequest as json.
func (s *UpdateTimeEntryBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateTimeEntryBadRequest from json.
func (s *UpdateTimeEntryBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTimeEntryBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateTimeEntryBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTimeEntryBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTimeEntryBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTimeEntryInternalServerError as json.
func (s *UpdateTimeEntryInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateTimeEntryInternalServerError from json.
func (s *UpdateTimeEntryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTimeEntryInternalServerError to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateTimeEntryInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTimeEntryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTimeEntryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTimeEntryRequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTimeEntryRequestBody) encodeFields(e *jx.Encoder) {
	{
		if s.TestField.Set {
			e.FieldStart("testField")
			s.TestField.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateTimeEntryRequestBody = [1]string{
	0: "testField",
}

// Decode decodes UpdateTimeEntryRequestBody from json.
func (s *UpdateTimeEntryRequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTimeEntryRequestBody to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "testField":
			if err := func() error {
				s.TestField.Reset()
				if err := s.TestField.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"testField\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTimeEntryRequestBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTimeEntryRequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTimeEntryRequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTimeEntryUnauthorized as json.
func (s *UpdateTimeEntryUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateTimeEntryUnauthorized from json.
func (s *UpdateTimeEntryUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTimeEntryUnauthorized to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateTimeEntryUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTimeEntryUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTimeEntryUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
